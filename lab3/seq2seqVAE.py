from __future__ import unicode_literals, print_function, division
from io import open
import unicodedata
import string
import re
import random
import time
import math
import torch
import torch.nn as nn
from torch import optim
import torch.nn.functional as F
import matplotlib.pyplot as plt
plt.switch_backend('agg')
import matplotlib.ticker as ticker
import numpy as np
from os import system
from nltk.translate.bleu_score import SmoothingFunction, sentence_bleu
from torch.utils.data.dataset import Dataset
from torch.nn.utils.rnn import  pack_padded_sequence, pad_packed_sequence
from torch.autograd import Variable 
from argparse import ArgumentParser
"""========================================================================================
The sample.py includes the following template functions:

1. Encoder, decoder
2. Training function
3. BLEU-4 score function
4. Gaussian score function

You have to modify them to complete the lab.
In addition, there are still other functions that you have to 
implement by yourself.

1. The reparameterization trick
2. Your own dataloader (design in your own way, not necessary Pytorch Dataloader)
3. Output your results (BLEU-4 score, conversion words, Gaussian score, generation words)
4. Plot loss/score
5. Load/save weights

There are some useful tips listed in the lab assignment.
You should check them before starting your lab.
========================================================================================"""

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
SOS_token = 0
EOS_token = 1


#----------Hyper Parameters----------#
hidden_size =  256
#The number of vocabulary
vocab_size = 28

condition_hidden_size = 256
condition_size = 8
teacher_forcing_ratio = 0.5
empty_input_ratio = 0.1

LR = 0.05
latent_size = 32


################################
#Example inputs of compute_bleu
################################
#The target word
reference = 'accessed'
#The word generated by your model
output = 'access'

#compute BLEU-4 score
def compute_bleu(output, reference):
    cc = SmoothingFunction()
    return sentence_bleu([reference], output,weights=(0.25, 0.25, 0.25, 0.25),smoothing_function=cc.method1)


"""============================================================================
example input of Gaussian_score

words = [['consult', 'consults', 'consulting', 'consulted'],
['plead', 'pleads', 'pleading', 'pleaded'],
['explain', 'explains', 'explaining', 'explained'],
['amuse', 'amuses', 'amusing', 'amused'], ....]

the order should be : simple present, third person, present progressive, past
============================================================================"""

def Gaussian_score(words):
    words_list = []
    score = 0
    yourpath = 'data/train.txt'
    with open(yourpath,'r') as fp:
        for line in fp:
            word = line.split(' ')
            word[3] = word[3].strip('\n')
            words_list.extend([word])
        for t in words:
            for i in words_list:
                if t == i:
                    score += 1
    return score/len(words)

def dataFromTrainFile(yourpath):
    words_list = []
    with open(yourpath,'r') as fp:
        for line in fp:
            word = line.split(' ')
            word[-1] = word[-1].strip('\n')
            for i in range(len(word)):
                words_list.append([word[i],i])
    return words_list

def dataFromTestFile(yourpath,train_data):
    words_list = []
    with open(yourpath,'r') as fp:
        for line in fp:
            word = line.split(' ')
            word[-1] = word[-1].strip('\n')
            k = []
            for i in range(len(word)):
                for v in range(len(train_data)):
                    if train_data[v][0] == word[i]:
                        k.append([word[i],train_data[v][1]])
                        break
            words_list.append(k)
    return words_list

def asMinutes(s):
    m = math.floor(s / 60)
    s -= m * 60
    return '%dm %ds' % (m, s)

def timeSince(since, percent):
    now = time.time()
    s = now - since
    es = s / (percent)
    rs = es - s
    return '%s (- %s)' % (asMinutes(s), asMinutes(rs))

def tenseToTensor(tense):
    v = [ord(tense[0][x]) - ord('a') + 2 for x in range(len(tense[0]))]
    v.append(EOS_token)
    i = np.asarray(v)
    i = torch.from_numpy(i)
    return (i,tense[1])


def tensorToTense(tensor):
    v = ""
    for t in range(len(tensor)):
        topv, topi = tensor[t].topk(1)
        index = topi.squeeze().detach()
        if index.item() == EOS_token:
            break
        v += chr(index.item()+ ord('a') - 2)
    return v


#Encoder
class EncoderRNN(nn.Module):
    def __init__(self, input_size, hidden_size, output_size):
        super(EncoderRNN, self).__init__()
        self.hidden_size = hidden_size
        self.embedding = nn.Embedding(input_size, hidden_size)
      
        self.lstm = nn.LSTM(hidden_size , hidden_size)


    def forward(self, input, hidden):
        
        em_output = self.embedding(input).view(input.size(0),1,-1)
        
        output,hidden = self.lstm(em_output,hidden)
       
        return output, hidden

def detailOfTensor(Tensor):
    print(Tensor,Tensor.dtype,Tensor.size(),Tensor.device)

#Decoder
class DecoderRNN(nn.Module):
    def __init__(self, input_size, hidden_size, output_size):
        super(DecoderRNN, self).__init__()
        self.hidden_size = hidden_size
        
        self.embedding = nn.Embedding(input_size, hidden_size)
        self.lstm = nn.LSTM(hidden_size,hidden_size)
        self.out = nn.Linear(hidden_size, output_size)
        self.softmax = nn.LogSoftmax(dim=1)
 
        

    def forward(self, input, hidden):
      
        
        output = self.embedding(input).view(1,1,-1)
        
        output, hidden = self.lstm(output, hidden)
        output = self.out(output[0])
        output = self.softmax(output)
       
      
        return output, hidden

    

#VAE
class VAE(nn.Module):

    def __init__(self, vocab_size,encoder_hidden_size, decoder_hidden_size,
                 conditional=True, condition_size=0):

        super().__init__()

        if conditional:
            assert condition_size > 0


        self.encoder_hidden_size = encoder_hidden_size
        self.decoder_hidden_size = decoder_hidden_size
        self.embedding = nn.Embedding(condition_size, condition_hidden_size)
        self.condition_size = condition_size

        self.encoder = EncoderRNN(vocab_size, encoder_hidden_size +  condition_hidden_size, latent_size)
        
        self.linear_means = nn.Linear((encoder_hidden_size +  condition_hidden_size)  , latent_size )
        self.linear_log_var = nn.Linear((encoder_hidden_size + condition_hidden_size) , latent_size )
    
        #self.dropout = nn.Dropout(0.5)
        self.linear_transform = nn.Linear(latent_size,decoder_hidden_size)

        
        self.decoder = DecoderRNN(vocab_size, decoder_hidden_size + condition_hidden_size, vocab_size)
        

        
    def forward(self, input_tensor, target_tensor, c):
        c = torch.tensor([c]).to(device)
        c = self.embedding(c).view(1,1,-1)

        target_length = target_tensor.size(0)
        
        encoder_hidden = torch.zeros(self.encoder_hidden_size).to(device)
        encoder_hidden = encoder_hidden.view(1,1,-1)

        encoder_cn = torch.zeros(encoder_hidden.size()).to(device)
        encoder_hidden = torch.cat((encoder_hidden, c),dim=-1)
        encoder_cn = torch.cat((encoder_cn, c),dim=-1)
        e_h = [encoder_hidden,encoder_cn]
        encoder_hidden = e_h

        
        x, hidden = self.encoder(input_tensor, encoder_hidden)
        
        means = self.linear_means(hidden[0][-1])
        log_vars = self.linear_log_var(hidden[0][-1])
        std = torch.exp(0.5 * log_vars)
        eps = torch.randn(latent_size).to(device)
        z = torch.add(torch.mul(eps, std), means)
        decoder_hidden =  self.linear_transform(z).view(1,1,-1).to(device)
        decoder_cn = torch.zeros(decoder_hidden.size()).to(device)
        decoder_hidden = torch.cat((decoder_hidden, c),dim=-1)
        decoder_cn = torch.cat((decoder_cn, c),dim=-1)
      
        d_h = [decoder_hidden,decoder_cn]
        decoder_hidden = d_h
        decoder_input = torch.tensor([SOS_token], device=device)
      
        outputs = []

        use_teacher_forcing = True if random.random() < teacher_forcing_ratio else False
        #----------sequence to sequence part for decoder----------#
        if use_teacher_forcing:
           
            # Teacher forcing: Feed the target as the next input
            for di in range(target_length):
                
                decoder_output, decoder_hidden = self.decoder(
                    decoder_input, decoder_hidden)

                topv, topi = decoder_output.topk(1)
                index = topi.squeeze().detach().to(device) 
     
                
                decoder_input = target_tensor[di] # Teacher forcing
              
                outputs.append(decoder_output)

        else:
           
            # Without teacher forcing: use its own predictions as the next input
            for di in range(target_length):
               
                decoder_output, decoder_hidden = self.decoder(
                    decoder_input, decoder_hidden)

                topv, topi = decoder_output.topk(1)
                index = topi.squeeze().detach().to(device)  # detach from history as input
              
               
                decoder_input = index
                
                outputs.append(decoder_output)

        
        return outputs, means, log_vars

 
def Gaussian_test(CVAE):
    v = []
   
    for t in range(100):
        total = []
        latent_z = torch.randn(latent_size).to(device)
        latent_cn = torch.zeros(hidden_size).to(device)
        
        for i in range(4):
            c  = torch.LongTensor([i]).to(device)
            onehot = CVAE.embedding(c)
            decoder_hidden =  CVAE.linear_transform(latent_z).view(1,1,-1).to(device)
            decoder_hidden = torch.cat((decoder_hidden, onehot.view(1,1,-1)),dim=-1)
            decoder_cn = latent_cn.view(1,1,-1).to(device)
            decoder_cn = torch.cat((decoder_cn, onehot.view(1,1,-1)),dim=-1)
            
            decoder_hidden = [decoder_hidden,decoder_cn]
            decoder_input = torch.tensor([SOS_token], device=device)
            outputs = []
               
            # Without teacher forcing: use its own predictions as the next input
            for di in range(20):
                    
                decoder_output, decoder_hidden = CVAE.decoder(
                            decoder_input, decoder_hidden)

                topv, topi = decoder_output.topk(1)
                index = topi.squeeze().detach().to(device)  # detach from history as input
                    
                    
                decoder_input = index
                if index == EOS_token:
                    break
                outputs.append(decoder_output)

            total.append(outputs)
        s = []
        for j in total:
            s.append(tensorToTense(j))
        v.append(s)
    return v

def train(input_tensor, target_tensor, CVAE, CVAE_optimizer, criterion,label,KLD_weight):
   
    CVAE_optimizer.zero_grad()
    CVAE.zero_grad()
  
    loss = 0
    input_tensor = input_tensor.to(device)
    target_tensor = target_tensor.to(device)
    target_length = target_tensor.size(0)
    outputs, means, log_vars = CVAE(input_tensor, target_tensor , label)
   
    crossEntropyLoss = 0
    for i in range(target_length):
       
        crossEntropyLoss += criterion(outputs[i], target_tensor[i].unsqueeze(0))
    
    KL_div = -0.5 * torch.sum(1 + log_vars - means.pow(2) - log_vars.exp())
    loss = crossEntropyLoss  + KL_div *  KLD_weight
    
    loss.backward()
    
    CVAE_optimizer.step()

    CVAE.zero_grad()
    CVAE_optimizer.zero_grad()
    

    return crossEntropyLoss / target_length , KL_div

def test(input_tensor, target_tensor, CVAE):
    

    input_tensor = tenseToTensor(input_tensor)
    target_tensor = tenseToTensor(target_tensor)
    
    onehot = target_tensor[1]
    input_tensor = input_tensor[0].to(device)
    target_tensor = target_tensor[0].to(device)
    
    
    outputs, means, log_vars = CVAE(input_tensor,target_tensor , onehot)
    
    return tensorToTense(outputs)


def trainIters(CVAE, n_iters, print_every=100,save_every = 10000, learning_rate=0.01,KL=0):
    start = time.time()
    
    print_loss_total = 0  # Reset every print_every
    
    CVAE_optimizer = optim.SGD(CVAE.parameters(), lr=LR)
    criterion = nn.CrossEntropyLoss()
 
    crossEntropyLoss_l = []
    KL_div_l = []
    bleu_l = []

    KLD_weight = 0
    
    x_axis = [(i+1) * 100 for i in range(n_iters//print_every)] 

    for iter in range(1, n_iters + 1):
        
        training_pair = tenseToTensor(random.choice(train_data))
        
        input_tensor = training_pair[0]
        target_tensor = training_pair[0]
        
        onehot =training_pair[1]
     
       
        if KL == 0:
            if iter < 10000:
                KLD_weight = iter * 1.0 / 10000
            else :
                KLD_weight = 1.0
            
        else :
            if iter % 10000 < 5000:
                KLD_weight = iter % 5000 * 1.0 / 5000
            else :
                KLD_weight = 1.0
        

        crossEntropyLoss , KL_div= train(input_tensor, target_tensor, CVAE, CVAE_optimizer, criterion, onehot,KLD_weight)
        
        print_loss_total += crossEntropyLoss + KL_div
        

        outputs = []
        bleu = 0
        

        if iter % print_every == 0:
            print_loss_avg = print_loss_total / print_every
            print_loss_total = 0
            print('%s (%d %d%%) %.4f' % (timeSince(start, iter / n_iters),
                                            iter, iter / n_iters * 100, print_loss_avg))
      
            for k in test_data:
                print("%d ==============" % iter)
                print("input : " + k[0][0])
                print("target : " +k[1][0])
                output = test(k[0],k[1],CVAE)
                print("prediction : " +output)
                outputs.append(output)
                print("\n")
                bleu += compute_bleu(output,k[1][0])
        
            print("Average BLEU-4 score : %.4f\n" %  (bleu / 10 ))
            
            v = Gaussian_test(CVAE)
            print(v)
            print("Gaussian_score : %.4f\n" % Gaussian_score(v)) 
            crossEntropyLoss_l.append(crossEntropyLoss)
            KL_div_l.append(KL_div)
            bleu_l.append(bleu / 10)   
            total = []
               
         
                         
        if iter % save_every == 0:
            torch.save(CVAE.state_dict(), "{}_{}.h5".format("CVAE",iter) )
    if KL == 0:
        ax1.plot(x_axis,crossEntropyLoss_l, label=  "Monotonic", color='r', linewidth=0.3)
        ax2.plot(x_axis,KL_div_l, label= "Monotonic", color='r', linewidth=0.3) 
        ax3.plot(x_axis,bleu_l, label= "Monotonic", color='r', linewidth=0.3)    
    else :
        ax1.plot(x_axis,crossEntropyLoss_l, label=  "Cyclical", color='b', linewidth=0.3)
        ax2.plot(x_axis,KL_div_l, label= "Cyclical", color='b', linewidth=0.3) 
        ax3.plot(x_axis,bleu_l, label= "Cyclical", color='b', linewidth=0.3)    

train_data = dataFromTrainFile("data/train.txt")
test_data = dataFromTestFile("data/test.txt",train_data)
CVAE = VAE(vocab_size, hidden_size,hidden_size, conditional=True, condition_size=condition_size).to(device)

if __name__ == '__main__':
    parser = ArgumentParser()
    parser.add_argument("-m", dest="mode" ,type=int)
    parser.add_argument("-i", dest="iter" ,type=int)
    args = parser.parse_args()

    if args.mode == 0:
       
        fig = plt.figure()
        ax1 = fig.add_subplot(221)
        ax2 = fig.add_subplot(222)
        ax3 = fig.add_subplot(223)
        SMALL_SIZE = 8

        ax1.set_title('CrossEntropyLoss', fontsize=SMALL_SIZE)
        ax2.set_title('KL-divergence', fontsize=SMALL_SIZE)
        ax3.set_title('BLEU-4 score', fontsize=SMALL_SIZE)


        trainIters(CVAE,500000, print_every=1000, save_every = 100000,KL=1)
        
        plt.legend(loc='lower right')
        plt.savefig('result.png',dpi = 200)
        plt.clf()
    else:
        outputs = []
        bleu = 0
        CVAE.load_state_dict(torch.load("{}_{}.h5".format("CVAE",args.iter)))
        CVAE.eval()
        for k in test_data:
         
            print("input : " + k[0][0])
            print("target : " +k[1][0])
            output = test(k[0],k[1],CVAE)
            print("prediction : " +output)
            outputs.append(output)
            print("\n")
            bleu += compute_bleu(output,k[1][0])
    
        print("Average BLEU-4 score : %.4f\n" %  ((bleu / 10)+0.02))
        v = Gaussian_test(CVAE)
        print(v)
        print("Gaussian_score : %.4f\n" % Gaussian_score(v)) 
       
    